function patches = dcp_extract(params, discovery_set, world_set)
% param1: discovery_set: discovery image set. The filenames of the images
%         from which discriminative patches should be extracted
%         (different resolutions between the images are allowed)
% param2: world_set: HOG-Descriptor matrix of the initially generated
%         "natural world set". A natural world set can be generated by
%         executing 'dcp_generate_world_set.m'
% return: The extracted most discriminative patches organised as cell array
% 
% Before calling this function, make sure that a valid world set is present.
% Otherwise generate it by executing 'dcp_generate_world_set.m' once

%==========================================================================
% Initial steps

npictures = size(discovery_set,1);

% extract patches from all images
npatches_per_pic = min(ceil(params.npatches*params.one_patch_out_of/npictures),...
                       params.max_npatches_per_pic);


hog_patches = cell(1, npatches_per_pic*npictures);
for i = 1:npictures
    % read image
    I = im2single(vl_imreadgray(discovery_set{i}));
    
    % extract random patches of the discovery set
    % random patches
    patches = dcp_get_random_patches(params, I, npatches_per_pic);
    if isempty(patches)
        display('An error occured with the input data');
        patches = [];
        return; 
    end
    
    % calculate HOG descriptors of dicovery set (for each patch)
    for j = 1:size(patches,2)
        
        hog = dcp_hog(params, patches{j}.data);
        idx = (i-1)*npatches_per_pic + j;
        hog_patches{idx}.hog = hog;
        hog_patches{idx}.img_nr = i;
        hog_patches{idx}.rect = patches{j}.rect;
    end
    
end

display(['init: extracted ' num2str(size(hog_patches,2)) ' patches']);


% permutate patches of both discovery and world set randomly and
% shuffled_indizes = randperm(size(hog_patches,2));

% divide D and N into D1,D2 and N1,N2
%D1 = shuffled_indizes(1:ceil(size(hog_patches,2)/2));
%D2 = shuffled_indizes(ceil(size(hog_patches,2)/2)+1:size(hog_patches,2));

%shuffled_indizes = randperm(1:size(world_patches,2));
%N1 = shuffled_indizes(1:ceil(size(world_patches,2)/2));
%N2 = shuffled_indizes(ceil(size(world_patches,2)/2)+1:size(world_patches,2));

% divide patches of discovery_set and world_set into two subsets
% to avoid copying data, use D1, D2, N1 and N2 just as an index
D1 = 1:ceil(size(hog_patches,2)/2);
D2 = ceil(size(hog_patches,2)/2)+1:size(hog_patches,2);
N1 = 1:ceil(size(world_set,2)/2);
N2 = ceil(size(world_set,2)/2)+1:size(world_set,2);

% sample subset S of D1 for k-means
S = dcp_init_sample_for_kmeans(params, D1, hog_patches);

% cluster patches using k-means and prune the clusters
Clusters = dcp_kmeans(params, S, hog_patches);

%==========================================================================
% Iterative Part
display([num2str(size(Clusters,1)), ' Clusters left']);
display('starting iterative part...');
for j = 1:1   % TODO: -> while converged()
    to_delete = [];
    for i = 1:size(Clusters,2)
        Clusters{i}.C = dcp_train_svm(params, D1(Clusters{i}.members), hog_patches, N1, world_set);
        Clusters{i} = dcp_detect_top(params, Clusters{i}.C, D2, hog_patches);
        if size(Clusters{i}.members,2) < params.svm_prune_clusters_thres
            to_delete = [to_delete i];
        end
    end
    Clusters(to_delete) = []; % prune out small clusters
    display([num2str(size(Clusters,1)), ' Clusters left']);
    
    temp = D1; D1 = D2; D2 = temp; % swap D1, D2
    temp = N1; N1 = N2; N2 = temp; % swap N1, N2
    
end

% get the best


% return the patch information
patches = cell(1,size(the_best,2));
for i = 1:size(the_best,2)
    patches{i}.img_nr = hog_patches{the_best(i)}.img_nr;
    patches{i}.rect   = hog_patches{i}.rect;
end


