function patches = dcp_extract(params, discovery_set, world_set)
% param1: discovery_set: discovery image set. The filenames of the images
%         from which discriminative patches should be extracted
%         (different resolutions between the images are allowed)
% param2: world_set: HOG-Descriptor matrix of the initially generated
%         "natural world set". A natural world set can be generated by
%         executing 'dcp_generate_world_set.m'
% return: The extracted most discriminative patches organised as cell array
% 
% Before calling this function, make sure that a valid world set is present.
% Otherwise generate it by executing 'dcp_generate_world_set.m' once

%==========================================================================
% Initial steps

npictures = size(discovery_set,1);

% extract patches from all images
npatches_per_pic = min(ceil(params.npatches*params.one_patch_out_of/npictures),...
                       params.max_npatches_per_pic);


hog_patches = cell(1, npatches_per_pic*npictures);
img_sizes = zeros(npictures, 2);
for i = 1:npictures
    % read image
    I = im2single(vl_imreadgray(discovery_set{i}));
    img_sizes(i,:) = size(I);
    % extract random patches of the discovery set
    % random patches
    patches = dcp_get_random_patches(params, I, npatches_per_pic);
    if isempty(patches)
        display('An error occured with the input data');
        patches = [];
        return; 
    end
    
    % calculate HOG descriptors of dicovery set (for each patch)
    for j = 1:size(patches,2)
        
        hog = dcp_hog(params, patches{j}.data);
        idx = (i-1)*npatches_per_pic + j;
        hog_patches{idx}.hog = hog;
        hog_patches{idx}.img_nr = i;
        hog_patches{idx}.rect = patches{j}.rect;
    end
    display(['Patches of Image ', num2str(i), ' of ', num2str(npictures), ' extracted'])
end
clear patches;
display(['Total ' num2str(size(hog_patches,2)) ' patches extracted']);


% permutate patches of both discovery and world set randomly and
shuffled_indizes = randperm(size(hog_patches,2));

% divide D and N into D1,D2 and N1,N2
D1 = shuffled_indizes(1:ceil(size(hog_patches,2)/2));
D2 = shuffled_indizes(ceil(size(hog_patches,2)/2)+1:size(hog_patches,2));

%shuffled_indizes = randperm(1:size(world_patches,2));
%N1 = shuffled_indizes(1:ceil(size(world_patches,2)/2));
%N2 = shuffled_indizes(ceil(size(world_patches,2)/2)+1:size(world_patches,2));

% divide patches of discovery_set and world_set into two subsets
% to avoid copying data, use D1, D2, N1 and N2 just as an index
%D1 = 1:ceil(size(hog_patches,2)/2);
%D2 = ceil(size(hog_patches,2)/2)+1:size(hog_patches,2);
N1 = 1:ceil(size(world_set,2)/2);
N2 = ceil(size(world_set,2)/2)+1:size(world_set,2);

% sample subset S of D1 for k-means
S = dcp_init_sample_for_kmeans(params, D1, hog_patches, npictures, img_sizes);
display([num2str(size(S,2)), ' Elements in S']);

% cluster patches using k-means and prune the clusters
Clusters = dcp_kmeans(params, S, hog_patches);
display([num2str(size(Clusters,2)), ' Clusters formed']);

%==========================================================================
% Iterative Part
save('init.mat', 'hog_patches', 'Clusters', 'D1', 'D2', 'N1', 'N2', 'discovery_set', 'params');
display('Starting iterative part...');
for j = 1:params.niterations
    to_delete = [];
    for i = 1:size(Clusters,2)
        display(['Training SVM of cluster ', num2str(i), '/', num2str(size(Clusters,2)), ...
                 ', consisting of ', num2str(numel(Clusters{i}.members)), ' members']);
        Clusters{i}.C = dcp_train_svm(params, Clusters{i}.members, hog_patches, N1, world_set);
        display(['Detecting top patches of cluster ', num2str(i), '/', num2str(size(Clusters,2))]);
        Clusters{i} = dcp_detect_top(params, Clusters{i}.C, D2, hog_patches);
        if size(Clusters{i}.members,2) < params.svm_prune_clusters_thres
            to_delete = [to_delete i];
        end
    end
    Clusters(to_delete) = []; % prune out small clusters
    display([num2str(size(Clusters,2)), ' Clusters left after ',...
             num2str(j), '/', num2str(params.niterations), ' iterations']);
    
    temp = D1; D1 = D2; D2 = temp; % swap D1, D2
    temp = N1; N1 = N2; N2 = temp; % swap N1, N2
    
    save(['iter',num2str(j),'.mat'], 'Clusters');
    if params.show_intermediate_results
        patches = dcp_get_patches_of_best_cluster(params, Clusters, 'members', hog_patches);
        dcp_visualise_patches(params, patches, discovery_set, true, j, true);
    end
    
end

%score the clusters
display(['Training finished. Detecting the best cluster...']);
Clusters = dcp_score_cluster(params, Clusters, world_set, hog_patches);
save('after_score.mat','Clusters');

% select top
display(['Get patches of best cluster...']);
patches = dcp_get_patches_of_best_cluster(params, Clusters, 'topRPatchesIndex', hog_patches);


end